/* This class is generated by ObjCTemplar, please do not modify it */

#import "{{ class.class_name }}.h"{% if class.supports_track_changes? %}
#import "TCTrackChangesImplementation.h"{% endif %}
{% for other_class in other_classes %}#import "{{ other_class }}.h"
{% endfor %}
@interface {{ class.class_name }} ()

{% if class.supports_builder? %}- (instancetype _Nonnull)initWithBuilder:({{ class.class_name }}Builder * _Nonnull)builder;
{% endif %}{% for property in class.all_properties %}{% if property.validate? %}- (BOOL){{ property.validator_name }}:({{ property.type }}){{ property.name }} error:(NSError **error);
{% endif %}{% endfor %}
@end

@implementation {{ class.class_name }}

{% if class.close_parent_ctor? %}#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-designated-initializers"
- (instancetype _Nonnull)init{{ class.parent.prim_ctor_definition }} {
    NSAssert(NO, @"Forbidden");
    @throw [NSException exceptionWithName:@"Forbidden" reason:@"This object have its own immutable fields" userInfo:nil];
}
#pragma clang diagnostic pop

{% endif %}- (instancetype _Nonnull)init{{ class.prim_ctor_definition }} {
    if (self = [super init{{ class.parent.prim_ctor_call }}]) { {% for property in class.own_immutable_properties %}
        {{ property.field_name }} = {% if property.copy_on_assign? %}[{{ property.name}} copy]{% else %}{{ property.name }}{% endif %};{% endfor %}
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

- (instancetype _Nonnull)init{{ class.copy_ctor_definition }} {
    NSParameterAssert({{class.copy_ctor_param}} != nil);

    if (self = [super init{{ class.parent.copy_ctor_call }}]) { {% for property in class.own_properties %}
        {{ property.field_name }} = {% if property.copy_on_assign? %}[{{class.copy_ctor_param}}->{{ property.field_name }} copy]{% else %}{{class.copy_ctor_param}}->{{ property.field_name }}{% endif %};{% endfor %}
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

{% if class.supports_builder? %}
- (instancetype _Nonnull)initWithBuilder:({{ class.class_name }}Builder * _Nonnull)builder {
    NSParameterAssert(builder != nil);

    if (self = [self init{{ class.prim_ctor_call_for_builder }}]) { {% for property in class.all_mutable_properties %}
        {{ property.field_name }} = {% if property.copy_on_assign? %}[builder.{{ property.name }} copy]{% else %}builder.{{ property.name }}{% endif %};{% endfor %}
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

+ ({{ class.class_name }}Builder * _Nonnull)builder {
    {{ class.class_name }}Builder *builder = [[{{ class.class_name }}Builder alloc] init];

    NSAssert(builder != nil, @"Internal error: builder was not created");
    return builder;
}
{% endif %}

{% if class.supports_mutable_copy? %}
- (id)mutableCopyWithZone:(NSZone *)zone {
    {{ class.class_name }} *{{ class.copy_ctor_param }} = self;
    {{ class.copy_ctor_param }} = [[{{class.mutable_class_name}} allocWithZone:zone] init{{ class.copy_ctor_call }}];

    NSAssert({{ class.copy_ctor_param }} != nil, @"Internal error: object was not copied");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.mutable_class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return {{ class.copy_ctor_param }};
} {% endif %}

{% for property in class.all_properties %}{% if property.validate? %}- (BOOL){{ property.validator_name }}:({{ property.type }}){{ property.name }} error:(NSError **error) {
    for (id<SCValidator>> *validator in @[ {% for validator in property.validators %}[[{{ validator }} alloc] init], {% endfor %} ]) {
        if (![validator validateValue:{{ property.name_boxed }} ofProperty:@"{{ property.name }}" forObject:self error:error]) {
            return NO;
        }
    }
    return YES;
}

{% endif %}{% endfor %}

{% for property in class.own_properties %}@dynamic {{ property.name }};

- ({{ property.type_qualified }}){{ property.name }} {
    return {{ property.field_name }};
}

{% endfor %}@end

{% if class.supports_mutable_copy? %}
@interface {{ class.mutable_class_name }} () {% if class.supports_track_changes? %}{
    TCTrackChangesImplementation * _Nonnull _tracker;
}{% endif %}

@end

@implementation {{ class.mutable_class_name }}
{% if class.supports_track_changes? %}
- (instancetype _Nonnull)init{{ class.prim_ctor_definition }} {
    if (self = [super init{{ class.prim_ctor_call }}]) {
        _tracker = [[TCTrackChangesImplementation alloc] init];
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.mutable_class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

- (instancetype _Nonnull)init{{ class.copy_ctor_definition }} {
    NSParameterAssert({{class.copy_ctor_param}} != nil);

    if (self = [super init{{ class.copy_ctor_call }}]) {
        if ([item isKindOfClass:[{{ class.mutable_class_name }} class]]) {
            _tracker = [(({{ class.mutable_class_name }} *){{ class.copy_ctor_param }})->_tracker copy];
        } else {
            _tracker = [[TCTrackChangesImplementation alloc] init];
        }
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.mutable_class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

- (NSArray<NSString *> * _Nonnull)changedKeys {
    return _tracker.changedKeys;
}
{% endif %}
{% for property in class.all_mutable_properties %}@dynamic {{ property.name }};

- (void){{ property.setter_name }}:({{ property.type_qualified }}){{ property.name }} {% if property.validate? %}error:(NSError **)error{% endif %}{
    {% if property.validate? %}
    if (![self {{ property.validator_name}}:{{ property.name }} error:error]) { return; }
    {% endif %}
    if ({% if property.reference_type? %}![{{ property.field_name }} isEqual:{{ property.name }}]{% else %}{{ property.field_name }} != {{ property.name }}{% endif %}) {
        {% if class.supports_track_changes? %}[_tracker beforeValue:{{ property.field_name_boxed }} willBeChangedForKey:@"{{ property.name }}"];{% endif %}
        [self willChangeValueForKey:@"{{ property.name }}"];
        {{ property.field_name }} = {% if property.copy_on_assign? %}[{{ property.name}} copy]{% else %}{{ property.name }}{% endif %};
        [self didChangeValueForKey:@"{{ property.name }}"];
        {% if class.supports_track_changes? %}[_tracker newValue:{{ property.field_name_boxed }} wasSetForKey:@"{{ property.name }}"];{% endif %}
    }
}

{% endfor %}@end
{% endif %}

{% if class.supports_builder? %}
@implementation {{ class.class_name }}Builder
{% if class.abstract? %}- (instancetype _Nonnull)init {
    if (self = [super init]) {
        if (self.class == [{{ class.class_name }}Builder class]) {
            NSAssert(NO, @"Unable to create builder instance for abstract class {{ class.class_name }}");
            return nil;
        }
    }
    return self;
}{% endif %}
{% for property in class.builder_properties %}@synthesize {{ property.name }} = {{ property.field_name }};

{% endfor %}- ({{ class.class_name }} * _Nonnull)build {
    return [[{{ class.class_name }} alloc] initWithBuilder:self];
}

@end
{% endif %}