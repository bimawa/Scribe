/* This class is generated by ObjCTemplar, please do not modify it */
{% assign error_definition = 'error:(NSError **)error' %}
#import "{{ class.class_name }}.h"
#import {{ interfaces['validator']['in'] }}{% if class.supports_track_changes? %}
#import {{ interfaces['tracker']['in'] }}{% endif %}
{% for other_class in other_classes %}#import "{{ other_class }}.h"
{% endfor %}
{{ class.impl_imports }}

@interface {{ class.class_name }} ()

{% if class.supports_builder? %}- (instancetype)initWithBuilder:({{ class.class_name }}Builder *)builder{% if class.constructor_could_fail? %} error:(NSError **)error{% endif %};
{% endif %}{% for property in class.all_properties %}{% if property.validate? %}+ (BOOL){{ property.validator_name }}:({{ property.type }}){{ property.name }} forObject:({{ class.class_name }} *)object error:(NSError **)error;
{% endif %}{% endfor %}
@end

@implementation {{ class.class_name }}

{% if class.close_parent_ctor? %}#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-designated-initializers"
- (instancetype)init{{ class.parent.prim_ctor_definition }}{% if class.parent.constructor_could_fail? %} error:(NSError **)error{% endif %} {
    NSAssert(NO, @"Forbidden");
    @throw [NSException exceptionWithName:@"Forbidden" reason:@"This object have its own immutable fields" userInfo:nil];
}
#pragma clang diagnostic pop

{% endif %}- (instancetype)init{{ class.prim_ctor_definition }}{% if class.constructor_could_fail? %}error:(NSError **)error {% endif %} {
    {% for property in class.all_immutable_properties %}{% if property.validate? %}if (![{{ class.class_name }} {{ property.validator_name }}:{{ property.name }} forObject:nil error:error]) { return nil; }
    {% endif %}{% endfor %}
    if (self = [super init{{ class.parent.prim_ctor_call }}{% if class.parent.constructor_could_fail? %} error:error{% endif %}]) { {% for property in class.own_immutable_properties %}
        {{ property.field_name }} = {% if property.copy_on_assign? %}[{{ property.name}} copy]{% else %}{{ property.name }}{% endif %};{% endfor %}
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

- (instancetype)init{{ class.copy_ctor_definition }} {
    NSParameterAssert({{class.copy_ctor_param}} != nil);

    if (self = [super init{{ class.parent.copy_ctor_call }}]) { {% for property in class.own_properties %}
        {{ property.field_name }} = {% if property.copy_on_assign? %}[{{class.copy_ctor_param}}->{{ property.field_name }} copy]{% else %}{{class.copy_ctor_param}}->{{ property.field_name }}{% endif %};{% endfor %}
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

{% if class.archivable? %}
- (instancetype)initWithCoder:(NSCoder *)decoder {
    {% if class.constructor_could_fail? %}NSError *error = nil;{% endif %}
    {% for property in class.all_immutable_properties %}
    {{ property.type }}{{ property.name }} = [decoder {{ property.decoding_method }}:@"{{ property.name }}"];
    {% endfor %}
    if (self = [self init{{ class.prim_ctor_call }}{% if class.constructor_could_fail? %} error:&error{% endif %}]) {
        {% for property in class.all_mutable_properties %}{{ property.field_name }} = [decoder {{ property.decoding_method }}:@"{{ property.name }}"];
        {% endfor %}
    }
    return self;
}

- (void)encodeWithCoder:(NSCoder *)encoder {
    {% for property in class.all_properties %}[encoder {{ property.encoding_method }}:{{ property.field_name }} forKey:@"{{ property.name }}"];
    {% endfor %}
}
{% endif %}

{% if class.supports_builder? %}
- (instancetype _Nonnull)initWithBuilder:({{ class.class_name }}Builder * _Nonnull)builder {% if class.constructor_could_fail? %}error:(NSError **)error {% endif %} {
    NSParameterAssert(builder != nil);
    {% for property in class.all_immutable_properties %}{% if property.validate? %}if (![{{ class.class_name }} {{ property.validator_name }}:builder.{{ property.name }} forObject:nil error:error]) { return nil; }
    {% endif %}{% endfor %}
    if (self = [self init{{ class.prim_ctor_call_for_builder }}{% if class.constructor_could_fail? %} error:error{% endif %}]) { {% for property in class.all_mutable_properties %}
        {{ property.field_name }} = {% if property.copy_on_assign? %}[builder.{{ property.name }} copy]{% else %}builder.{{ property.name }}{% endif %};{% endfor %}
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

+ ({{ class.class_name }}Builder * _Nonnull)builder {
    {{ class.class_name }}Builder *builder = [[{{ class.class_name }}Builder alloc] init];

    NSAssert(builder != nil, @"Internal error: builder was not created");
    return builder;
}
{% endif %}

- (id)copyWithZone:(NSZone *)zone {
    return self;
}

- (BOOL)isImmutable {
    return YES;
}

- (id)immutableCopyWithError:(NSError **)error {
    {{ class.class_name }} *{{ class.copy_ctor_param }} = self;
    return [[{{class.class_name}} alloc] init{{ class.copy_ctor_call }}];
}

{% if class.supports_mutable_copy? %}
- (id)mutableCopyWithZone:(NSZone *)zone {
    {{ class.class_name }} *{{ class.copy_ctor_param }} = self;
    {{ class.copy_ctor_param }} = [[{{class.mutable_class_name}} allocWithZone:zone] init{{ class.copy_ctor_call }}];

    NSAssert({{ class.copy_ctor_param }} != nil, @"Internal error: object was not copied");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.mutable_class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return {{ class.copy_ctor_param }};
} {% endif %}

{% for property in class.all_properties %}{% if property.validate? %}+ (BOOL){{ property.validator_name }}:({{ property.type }}){{ property.name }} forObject:({{ class.class_name }} *)object error:(NSError **)error {
    for (NSObject<SCValidator> *validator in @[ {% for validator in property.validators %}[[{{ validator }} alloc] init], {% endfor %} ]) {
        if (![validator validateValue:{{ property.name_boxed }} ofProperty:@"{{ property.name }}" forObject:object error:error]) {
            return NO;
        }
    }
    return YES;
}

{% endif %}{% endfor %}

{% for property in class.own_properties %}@dynamic {{ property.name }};

- ({{ property.type_qualified }}){{ property.getter_name }} {
    return {{ property.field_name }};
}

{% endfor %}@end

{% if class.supports_mutable_copy? %}
@interface {{ class.mutable_class_name }} () {% if class.supports_track_changes? %}{
    NSObject<{{ interfaces['tracker']['protocol']['int'] }}> * _Nonnull _tracker;
}{% endif %}

@end

@implementation {{ class.mutable_class_name }}
{% if class.supports_track_changes? %}
- (instancetype)init{{ class.prim_ctor_definition }}{% if class.constructor_could_fail? %} error:(NSError **)error {% endif %} {
    if (self = [super init{{ class.prim_ctor_call }} {% if class.constructor_could_fail? %} error:error{% endif %}]) {
        _tracker = [{{ interfaces['tracker']['class'] }} trackerWithTrackingObject:self mode:SCPropertyChangesTrackerManualMode];
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.mutable_class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

- (instancetype)init{{ class.copy_ctor_definition }} {
    NSParameterAssert({{class.copy_ctor_param}} != nil);

    if (self = [super init{{ class.copy_ctor_call }}]) {
        if ([{{ class.copy_ctor_param }} isKindOfClass:[{{ class.mutable_class_name }} class]]) {
            _tracker = [(({{ class.mutable_class_name }} *){{ class.copy_ctor_param }})->_tracker copy];
        } else {
            _tracker = [{{ interfaces['tracker']['class'] }} trackerWithTrackingObject:self mode:SCPropertyChangesTrackerManualMode];
        }
    }

    NSAssert(self != nil, @"Internal error: object was not created");{% if class.abstract? %}
    NSAssert(self.class != [{{ class.mutable_class_name }} class], @"Unable to create instance of abstract class");{% endif %}
    return self;
}

- (id<{{interfaces['tracker']['protocol']['ext']}}>)changesTracker {
    return _tracker;
}
{% endif %}

- (id)copyWithZone:(NSZone *)zone {
    {{ class.mutable_class_name }} *{{ class.copy_ctor_param }} = self;
    return [[{{ class.mutable_class_name }} allocWithZone:zone] init{{ class.copy_ctor_call }}];
}

- (BOOL)isImmutable {
    return NO;
}

{% for property in class.all_mutable_properties %}@dynamic {{ property.name }};

- (void){{ property.setter_name }}({{ property.type_qualified }}){{ property.name }} {% if property.validate? %}error:(NSError **)error{% endif %}{
    {% if property.validate? %}if (![{{ class.class_name }} {{ property.validator_name}}:{{ property.name }} forObject:self error:error]) { return; }
    {% endif %}
    if ({% if property.reference_type? %}![{{ property.field_name }} isEqual:{{ property.name }}]{% else %}{{ property.field_name }} != {{ property.name }}{% endif %}) {
        {% if class.supports_track_changes? %}[_tracker property:@"{{ property.name }}" beforeChangeValue:{{ property.field_name_boxed }}];{% endif %}
        [self willChangeValueForKey:@"{{ property.name }}"];
        {{ property.field_name }} = {% if property.copy_on_assign? %}[{{ property.name}} copy]{% else %}{{ property.name }}{% endif %};
        [self didChangeValueForKey:@"{{ property.name }}"];
        {% if class.supports_track_changes? %}[_tracker property:@"{{ property.name }}" afterChangeValue:{{ property.field_name_boxed }}];{% endif %}
    }
}

{% if property.collection? %}
{% if property.array? %}
- (void)add{{ property.element_name_capitalized }}:({{ property.subsequent_generic_types[0] }}){{ property.element_name }}{% if property.validate? %} {{ error_definition }}{% endif %} {
    NSMutableArray *{{ property.name }} = [self.{{ property.name }} mutableCopy] ?: [NSMutableArray array];
    [{{ property.name }} addObject:{{ property.element_name }}];
    [self {{ property.setter_name }}{{ property.name }}{% if property.validate? %} error:error{% endif %}];
}

- (void)insert{{ property.element_name_capitalized }}:({{ property.subsequent_generic_types[0] }}){{ property.element_name }} atIndex:(NSUInteger)index{% if property.validate? %} {{ error_definition }}{% endif %} {
    NSMutableArray *{{ property.name }} = [self.{{ property.name }} mutableCopy] ?: [NSMutableArray array];
    [{{ property.name }} insertObject:{{ property.element_name }} atIndex:index];
    [self {{ property.setter_name }}{{ property.name }}{% if property.validate? %} error:error{% endif %}];
}

- (void)remove{{ property.element_name_capitalized  }}:({{ property.subsequent_generic_types[0] }}){{ property.element_name }}{% if property.validate? %} {{ error_definition }}{% endif %} {
    NSMutableArray *{{ property.name }} = [self.{{ property.name }} mutableCopy];
    [{{ property.name }} removeObject:{{ property.element_name }}];
    [self {{ property.setter_name }}{{ property.name }}{% if property.validate? %} error:error{% endif %}];
}
{% elsif property.dictionary? %}
- (void)set{{ property.element_name_capitalized }}:({{ property.subsequent_generic_types[1] }}){{ property.element_name }} forKey:({{ property.subsequent_generic_types[0] }})key{% if property.validate? %} {{ error_definition }}{% endif %} {
    NSMutableDictionary *{{ property.name }} = [self.{{ property.name }} mutableCopy] ?: [NSMutableDictionary dictionary];
    [{{ property.name }} setObject:{{ property.element_name }} forKey:key];
    [self {{ property.setter_name }}{{ property.name }}{% if property.validate? %} error:error{% endif %}];
}

- (void)remove{{ property.element_name_capitalized }}ForKey:({{ property.subsequent_generic_types[0] }})key{% if property.validate? %} {{ error_definition }}{% endif %} {
    NSMutableDictionary *{{ property.name }} = [self.{{ property.name }} mutableCopy];
    [{{ property.name }} removeObjectForKey:key];
    [self {{ property.setter_name }}{{ property.name }}{% if property.validate? %} error:error{% endif %}];
}
{% elsif property.set? %}
- (void)add{{ property.element_name_capitalized }}:({{ property.subsequent_generic_types[0] }}){{ property.element_name }}{% if property.validate? %} {{ error_definition }}{% endif %} {
    NSMutableSet *{{ property.name }} = [self.{{ property.name }} mutableCopy] ?: [NSMutableSet set];
    [{{ property.name }} addObject:{{ property.element_name }}];
    [self {{ property.setter_name }}{{ property.name }}{% if property.validate? %} error:error{% endif %}];
}

- (void)remove{{ property.element_name_capitalized  }}:({{ property.subsequent_generic_types[0] }}){{ property.element_name }}{% if property.validate? %} {{ error_definition }}{% endif %} {
    NSMutableSet *{{ property.name }} = [self.{{ property.name }} mutableCopy];
    [{{ property.name }} removeObject:{{ property.element_name }}];
    [self {{ property.setter_name }}{{ property.name }}{% if property.validate? %} error:error{% endif %}];
}
{% endif %}
{% endif %}

{% endfor %}@end
{% endif %}

{% if class.supports_builder? %}
@implementation {{ class.class_name }}Builder
{% if class.abstract? %}- (instancetype)init {
    if (self = [super init]) {
        if (self.class == [{{ class.class_name }}Builder class]) {
            NSAssert(NO, @"Unable to create builder instance for abstract class {{ class.class_name }}");
            return nil;
        }
    }
    return self;
}{% endif %}
{% for property in class.builder_properties %}@synthesize {{ property.name }} = {{ property.field_name }};

{% endfor %}- ({{ class.class_name }} *)build{% if class.builder_could_fail? %}WithError:(NSError **)error{% endif %} {
    return [[{{ class.class_name }} alloc] initWithBuilder:self{% if class.constructor_could_fail? %} error:error{% endif %}];
}

@end
{% endif %}